<!DOCTYPE HTML>
<html>

<head>
	<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
	<title>无标题文档</title>

	<script>
		/*(function(){
									
			var a = 10;
			
			function $(){
				alert(a);
			}
			
			window.$ = $;
			
		})();

		//alert(a);

		$();

		//$() jQuery();*/


		(function (window, factory) {
			factory(widow)
		})(this, function () {
			return function () {
				//jQuery的调用
			}
		})

		(function (widow) {
			//jQuery的调用
		})(widow)
		
 		//任何库与框架设计的第一个要点就是解决命名空间与变量污染的问题。jQuery就是利用了JavaScript函数作用域的特性，采用立即调用表达式包裹了自身的方法来解决这个问题。
		(function (window, undefined) {
			var jQuery = function () {}
			// ...
			window.jQuery = window.$ = jQuery;
		})(window);

		$('#div1').css(); //实例方法
		$('#div1').html();

		var arr = new Array();
		arr.push();
		arr.sort();



		//$()执行时返回的是new 过后的对象，方便链式调用
		$().css();
		$().html();

		$.trim(); //工具方法，也叫静态方法
		$.proxy();





		$('ul li + p input.class').css();






		function fn1() {
			alert(1)
		}

		function fn2() {
			alert(2)
		}

		var cb = $.Callbacks();

		cb.add(fn1);
		cb.add(fn2);

		cb.fire(); //只要调用这个函数就会去执行fn1,fn2 1 ,2

		cb.remove(fn2);

		cb.fire(); //1











		/*setTimeout(function(){
			alert(1);
		},1000);

		alert(2);*/


		var dfd = $.Deferred();

		setTimeout(function () {
			alert(1);
			dfd.resolve();
		}, 1000);

		//先把这个函数存入到dfd中，当dfd.resolve()触发时再去执行函数，这是延迟对象实现的原理
		dfd.done(function () {
			alert(2);
		});



		$('#div1').data('name', 'hello'); //为了防止内存泄漏

		$('#div1').data('name'); //hello




		//队列只要用在动画处
		$('#div1').animate({
			left: 100
		});
		$('#div1').animate({
			top: 100
		});
		$('#div1').animate({
			width: 300
		});
	</script>
</head>

<body>

</body>

</html>